# Оптимизация badarg теста

## Проблема
Тест `badarg` вызывает `exec` 50,000 раз с невалидным адресом `0xffffffff` и таймаутит через 6 секунд.

## Решение
Оптимизировать функцию `uaddr_in_range` в файле `proc.c`, добавив быстрые проверки для заведомо невалидных адресов **до** выполнения дорогих операций с page table.

## Изменения

Замените функцию `uaddr_in_range` в вашем `proc.c` на оптимизированную версию:

```c
static inline int
uaddr_in_range(struct proc *p, uint64 uva, uint64 len)
{
  // Защита от переполнения
  if (len > 0 && uva + len < uva)
    return 0;
  
  // БЫСТРАЯ ПРОВЕРКА #1: адреса с установленным старшим битом (bit 63) 
  // являются kernel space адресами и невалидны для user space
  // Это ловит случаи вроде 0xffffffff (sign-extended до 0xffffffffffffffff)
  if (uva & (1ULL << 63))
    return 0;
  
  // БЫСТРАЯ ПРОВЕРКА #2: адреса в верхней части 32-битного диапазона
  // (>= 0xFFFFFFFF, т.е. 2^32-1) невалидны для user space
  // Это ловит 0xffffffff когда он zero-extended до 0x00000000ffffffff
  // Проверяем только если старшие 32 бита нулевые (чисто 32-битный адрес)
  // Адреса >= 0xFFFFFFFF в нижних 32 битах заведомо невалидны
  if ((uva >> 32) == 0 && (uva >= 0xFFFFFFFFULL)) {
    return 0;
  }
  
  // Проверка на явно невалидные адреса (>= MAXVA)
  if (uva >= MAXVA)
    return 0;
  if (len > 0 && uva + len > MAXVA)
    return 0;
  
  // Для остальных адресов < MAXVA пусть copyin/copyout сами проверят
  // через page table (это безопасно, так как они делают полную проверку)
  return 1;
}
```

## Как это работает

1. **Проверка #1**: Отлавливает адреса с установленным битом 63 (kernel space), включая случаи когда `0xffffffff` sign-extended до `0xffffffffffffffff`.

2. **Проверка #2**: Отлавливает адреса в верхней части 32-битного диапазона (>= 0xFFFFFFFF), включая случай когда `0xffffffff` zero-extended до `0x00000000ffffffff`.

Эти проверки выполняются **до** дорогих операций с page table, что значительно ускоряет обработку невалидных адресов.

## Ожидаемый результат

Тест `badarg` должен проходить значительно быстрее (с ~6 секунд до < 1 секунды), так как невалидные адреса будут отклоняться на раннем этапе без дорогих page table walks.
